// @uppy/utils/lib/RateLimitedQueue@6.1.1 downloaded from https://ga.jspm.io/npm:@uppy/utils@6.1.1/lib/RateLimitedQueue.js

function _classPrivateFieldLooseBase(e,s){if(!{}.hasOwnProperty.call(e,s))throw new TypeError("attempted to use private field on non-instance");return e}var e=0;function _classPrivateFieldLooseKey(s){return"__private_"+e+++"_"+s}function createCancelError(e){return new Error("Cancelled",{cause:e})}function abortOn(e){if(e!=null){var s;const abortPromise=()=>this.abort(e.reason);e.addEventListener("abort",abortPromise,{once:true});const removeAbortListener=()=>{e.removeEventListener("abort",abortPromise)};(s=this.then)==null||s.call(this,removeAbortListener,removeAbortListener)}return this}var s=_classPrivateFieldLooseKey("activeRequests");var i=_classPrivateFieldLooseKey("queuedHandlers");var t=_classPrivateFieldLooseKey("paused");var a=_classPrivateFieldLooseKey("pauseTimer");var r=_classPrivateFieldLooseKey("downLimit");var o=_classPrivateFieldLooseKey("upperLimit");var l=_classPrivateFieldLooseKey("rateLimitingTimer");var n=_classPrivateFieldLooseKey("call");var c=_classPrivateFieldLooseKey("queueNext");var u=_classPrivateFieldLooseKey("next");var v=_classPrivateFieldLooseKey("queue");var d=_classPrivateFieldLooseKey("dequeue");var h=_classPrivateFieldLooseKey("resume");var P=_classPrivateFieldLooseKey("increaseLimit");class RateLimitedQueue{constructor(e){Object.defineProperty(this,d,{value:_dequeue2});Object.defineProperty(this,v,{value:_queue2});Object.defineProperty(this,u,{value:_next2});Object.defineProperty(this,c,{value:_queueNext2});Object.defineProperty(this,n,{value:_call2});Object.defineProperty(this,s,{writable:true,value:0});Object.defineProperty(this,i,{writable:true,value:[]});Object.defineProperty(this,t,{writable:true,value:false});Object.defineProperty(this,a,{writable:true,value:void 0});Object.defineProperty(this,r,{writable:true,value:1});Object.defineProperty(this,o,{writable:true,value:void 0});Object.defineProperty(this,l,{writable:true,value:void 0});Object.defineProperty(this,h,{writable:true,value:()=>this.resume()});Object.defineProperty(this,P,{writable:true,value:()=>{if(_classPrivateFieldLooseBase(this,t)[t])_classPrivateFieldLooseBase(this,l)[l]=setTimeout(_classPrivateFieldLooseBase(this,P)[P],0);else{_classPrivateFieldLooseBase(this,r)[r]=this.limit;this.limit=Math.ceil((_classPrivateFieldLooseBase(this,o)[o]+_classPrivateFieldLooseBase(this,r)[r])/2);for(let e=_classPrivateFieldLooseBase(this,r)[r];e<=this.limit;e++)_classPrivateFieldLooseBase(this,c)[c]();_classPrivateFieldLooseBase(this,o)[o]-_classPrivateFieldLooseBase(this,r)[r]>3?_classPrivateFieldLooseBase(this,l)[l]=setTimeout(_classPrivateFieldLooseBase(this,P)[P],2e3):_classPrivateFieldLooseBase(this,r)[r]=Math.floor(_classPrivateFieldLooseBase(this,r)[r]/2)}}});this.limit=typeof e!=="number"||e===0?Infinity:e}run(e,i){return!_classPrivateFieldLooseBase(this,t)[t]&&_classPrivateFieldLooseBase(this,s)[s]<this.limit?_classPrivateFieldLooseBase(this,n)[n](e):_classPrivateFieldLooseBase(this,v)[v](e,i)}wrapSyncFunction(e,s){var i=this;return function(){for(var t=arguments.length,a=new Array(t),r=0;r<t;r++)a[r]=arguments[r];const o=i.run((()=>{e(...a);queueMicrotask((()=>o.done()));return()=>{}}),s);return{abortOn:abortOn,abort(){o.abort()}}}}wrapPromiseFunction(e,s){var i=this;return function(){for(var t=arguments.length,a=new Array(t),r=0;r<t;r++)a[r]=arguments[r];let o;const l=new Promise(((t,r)=>{o=i.run((()=>{let s;let i;try{i=Promise.resolve(e(...a))}catch(e){i=Promise.reject(e)}i.then((e=>{if(s)r(s);else{o.done();t(e)}}),(e=>{if(s)r(s);else{o.done();r(e)}}));return e=>{s=createCancelError(e)}}),s)}));l.abort=e=>{o.abort(e)};l.abortOn=abortOn;return l}}resume(){_classPrivateFieldLooseBase(this,t)[t]=false;clearTimeout(_classPrivateFieldLooseBase(this,a)[a]);for(let e=0;e<this.limit;e++)_classPrivateFieldLooseBase(this,c)[c]()}
/**
   * Freezes the queue for a while or indefinitely.
   *
   * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.
   *                                    If omitted, the queue won't resume automatically.
   */pause(e){e===void 0&&(e=null);_classPrivateFieldLooseBase(this,t)[t]=true;clearTimeout(_classPrivateFieldLooseBase(this,a)[a]);e!=null&&(_classPrivateFieldLooseBase(this,a)[a]=setTimeout(_classPrivateFieldLooseBase(this,h)[h],e))}
/**
   * Pauses the queue for a duration, and lower the limit of concurrent requests
   * when the queue resumes. When the queue resumes, it tries to progressively
   * increase the limit in `this.#increaseLimit` until another call is made to
   * `this.rateLimit`.
   * Call this function when using the RateLimitedQueue for network requests and
   * the remote server responds with 429 HTTP code.
   *
   * @param {number} duration in milliseconds.
   */rateLimit(e){clearTimeout(_classPrivateFieldLooseBase(this,l)[l]);this.pause(e);if(this.limit>1&&Number.isFinite(this.limit)){_classPrivateFieldLooseBase(this,o)[o]=this.limit-1;this.limit=_classPrivateFieldLooseBase(this,r)[r];_classPrivateFieldLooseBase(this,l)[l]=setTimeout(_classPrivateFieldLooseBase(this,P)[P],e)}}get isPaused(){return _classPrivateFieldLooseBase(this,t)[t]}}function _call2(e){_classPrivateFieldLooseBase(this,s)[s]+=1;let i=false;let t;try{t=e()}catch(e){_classPrivateFieldLooseBase(this,s)[s]-=1;throw e}return{abort:e=>{if(!i){i=true;_classPrivateFieldLooseBase(this,s)[s]-=1;t==null||t(e);_classPrivateFieldLooseBase(this,c)[c]()}},done:()=>{if(!i){i=true;_classPrivateFieldLooseBase(this,s)[s]-=1;_classPrivateFieldLooseBase(this,c)[c]()}}}}function _queueNext2(){queueMicrotask((()=>_classPrivateFieldLooseBase(this,u)[u]()))}function _next2(){if(_classPrivateFieldLooseBase(this,t)[t]||_classPrivateFieldLooseBase(this,s)[s]>=this.limit)return;if(_classPrivateFieldLooseBase(this,i)[i].length===0)return;const e=_classPrivateFieldLooseBase(this,i)[i].shift();if(e==null)throw new Error("Invariant violation: next is null");const a=_classPrivateFieldLooseBase(this,n)[n](e.fn);e.abort=a.abort;e.done=a.done}function _queue2(e,s){const t={fn:e,priority:(s==null?void 0:s.priority)||0,abort:()=>{_classPrivateFieldLooseBase(this,d)[d](t)},done:()=>{throw new Error("Cannot mark a queued request as done: this indicates a bug")}};const a=_classPrivateFieldLooseBase(this,i)[i].findIndex((e=>t.priority>e.priority));a===-1?_classPrivateFieldLooseBase(this,i)[i].push(t):_classPrivateFieldLooseBase(this,i)[i].splice(a,0,t);return t}function _dequeue2(e){const s=_classPrivateFieldLooseBase(this,i)[i].indexOf(e);s!==-1&&_classPrivateFieldLooseBase(this,i)[i].splice(s,1)}const _=Symbol("__queue");export{RateLimitedQueue,_ as internalRateLimitedQueue};

