// p-queue@8.1.0 downloaded from https://ga.jspm.io/npm:p-queue@8.1.0/dist/index.js

import{EventEmitter as e}from"eventemitter3";import t,{TimeoutError as i}from"p-timeout";function lowerBound(e,t,i){let r=0;let n=e.length;while(n>0){const s=Math.trunc(n/2);let u=r+s;if(i(e[u],t)<=0){r=++u;n-=s+1}else n=s}return r}class PriorityQueue{#e=[];enqueue(e,t){t={priority:0,...t};const i={priority:t.priority,id:t.id,run:e};if(this.size===0||this.#e[this.size-1].priority>=t.priority){this.#e.push(i);return}const r=lowerBound(this.#e,i,((e,t)=>t.priority-e.priority));this.#e.splice(r,0,i)}setPriority(e,t){const i=this.#e.findIndex((t=>t.id===e));if(i===-1)throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);const[r]=this.#e.splice(i,1);this.enqueue(r.run,{priority:t,id:e})}dequeue(){const e=this.#e.shift();return e?.run}filter(e){return this.#e.filter((t=>t.priority===e.priority)).map((e=>e.run))}get size(){return this.#e.length}}class PQueue extends e{#t;#i;#r=0;#n;#s;#u=0;#o;#a;#e;#h;#l=0;#c;#d;#v;#p=1n;timeout;constructor(e){super();e={carryoverConcurrencyCount:false,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:true,queueClass:PriorityQueue,...e};if(!(typeof e.intervalCap==="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString()??""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString()??""}\` (${typeof e.interval})`);this.#t=e.carryoverConcurrencyCount;this.#i=e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0;this.#n=e.intervalCap;this.#s=e.interval;this.#e=new e.queueClass;this.#h=e.queueClass;this.concurrency=e.concurrency;this.timeout=e.timeout;this.#v=e.throwOnTimeout===true;this.#d=e.autoStart===false}get#y(){return this.#i||this.#r<this.#n}get#m(){return this.#l<this.#c}#I(){this.#l--;this.#f();this.emit("next")}#g(){this.#w();this.#C();this.#a=void 0}get#q(){const e=Date.now();if(this.#o===void 0){const t=this.#u-e;if(!(t<0)){this.#a===void 0&&(this.#a=setTimeout((()=>{this.#g()}),t));return true}this.#r=this.#t?this.#l:0}return false}#f(){if(this.#e.size===0){this.#o&&clearInterval(this.#o);this.#o=void 0;this.emit("empty");this.#l===0&&this.emit("idle");return false}if(!this.#d){const e=!this.#q;if(this.#y&&this.#m){const t=this.#e.dequeue();if(!t)return false;this.emit("active");t();e&&this.#C();return true}}return false}#C(){if(!this.#i&&this.#o===void 0){this.#o=setInterval((()=>{this.#w()}),this.#s);this.#u=Date.now()+this.#s}}#w(){if(this.#r===0&&this.#l===0&&this.#o){clearInterval(this.#o);this.#o=void 0}this.#r=this.#t?this.#l:0;this.#P()}#P(){while(this.#f());}get concurrency(){return this.#c}set concurrency(e){if(!(typeof e==="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this.#c=e;this.#P()}async#T(e){return new Promise(((t,i)=>{e.addEventListener("abort",(()=>{i(e.reason)}),{once:true})}))}setPriority(e,t){this.#e.setPriority(e,t)}async add(e,r={}){r.id??=(this.#p++).toString();r={timeout:this.timeout,throwOnTimeout:this.#v,...r};return new Promise(((n,s)=>{this.#e.enqueue((async()=>{this.#l++;this.#r++;try{r.signal?.throwIfAborted();let i=e({signal:r.signal});r.timeout&&(i=t(Promise.resolve(i),{milliseconds:r.timeout}));r.signal&&(i=Promise.race([i,this.#T(r.signal)]));const s=await i;n(s);this.emit("completed",s)}catch(e){if(e instanceof i&&!r.throwOnTimeout){n();return}s(e);this.emit("error",e)}finally{this.#I()}}),r);this.emit("add");this.#f()}))}async addAll(e,t){return Promise.all(e.map((async e=>this.add(e,t))))}start(){if(!this.#d)return this;this.#d=false;this.#P();return this}pause(){this.#d=true}clear(){this.#e=new this.#h}
/**
    Can be called multiple times. Useful if you for example add additional items at a later time.

    @returns A promise that settles when the queue becomes empty.
    */async onEmpty(){this.#e.size!==0&&await this.#E("empty")}
/**
    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.

    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.

    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
    */async onSizeLessThan(e){this.#e.size<e||await this.#E("next",(()=>this.#e.size<e))}
/**
    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.

    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    */async onIdle(){this.#l===0&&this.#e.size===0||await this.#E("idle")}async#E(e,t){return new Promise((i=>{const listener=()=>{if(!t||t()){this.off(e,listener);i()}};this.on(e,listener)}))}get size(){return this.#e.size}sizeBy(e){return this.#e.filter(e).length}get pending(){return this.#l}get isPaused(){return this.#d}}export{PQueue as default};

